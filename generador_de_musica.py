# -*- coding: utf-8 -*-
"""generador de musica.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1I81Qzno8iBGTqYSR2_edfRC-Tz56B8nu
"""

import random

def generar_poblacion_inicial(tamanio_poblacion, longitud_cadena):
    poblacion = []
    for _ in range(tamanio_poblacion):
        individuo = ''.join(random.choice('cdefgabCDEFGAB') for _ in range(longitud_cadena))
        poblacion.append(individuo)
    return poblacion

def calcular_aptitud(individuo):
    notas = "cdefgabCDEFGAB"
    aptitud = 0

    for i in range(len(individuo) - 1):
        intervalo = calcular_intervalo(individuo[i], individuo[i + 1])
        if intervalo is not None and intervalo <= 3:
            aptitud += 1

    return aptitud

def seleccion(poblacion, aptitudes):
    total_aptitud = sum(aptitudes)
    probabilidades = [f / total_aptitud for f in aptitudes]
    padre1 = random.choices(poblacion, weights=probabilidades)[0]
    padre2 = random.choices(poblacion, weights=probabilidades)[0]
    return padre1, padre2

def cruza(padre1, padre2):
    punto_cruce = random.randint(1, len(padre1) - 1)
    hijo = padre1[:punto_cruce] + padre2[punto_cruce:]
    return hijo

def mutacion(individuo, tasa_mutacion):
    nuevo_individuo = list(individuo)
    for i in range(len(nuevo_individuo)):
        if random.random() < tasa_mutacion:
            nuevo_individuo[i] = random.choice('cdefgabCDEFGAB')
    return ''.join(nuevo_individuo)

def calcular_intervalo(nota1, nota2):
    notas = "cdefgabCDEFGAB"
    try:
        indice1 = notas.index(nota1)
        indice2 = notas.index(nota2)
        intervalo = abs(indice2 - indice1)
        return intervalo
    except ValueError:
        print("Nota no válida")
        return None

def algoritmo_genetico(tamanio_poblacion, tasa_mutacion, generaciones):
    poblacion = generar_poblacion_inicial(tamanio_poblacion, 6)
    for generacion in range(generaciones):
        aptitudes = [calcular_aptitud(individuo) for individuo in poblacion]
        nueva_poblacion = []
        mejor_individuo = None
        mejor_aptitud = -1

        for _ in range(tamanio_poblacion):
            padre1, padre2 = seleccion(poblacion, aptitudes)
            hijo = cruza(padre1, padre2)
            hijo = mutacion(hijo, tasa_mutacion)
            nueva_poblacion.append(hijo)

            # mejor combinación de la generación
            aptitud_hijo = calcular_aptitud(hijo)
            if aptitud_hijo > mejor_aptitud:
                mejor_individuo = hijo
                mejor_aptitud = aptitud_hijo

            #objetivo
            if aptitud_hijo == 5:
                print(f"¡Objetivo alcanzado en la generación {generacion}!")
                print(f"Combinación: {hijo}, Aptitud: {aptitud_hijo}")
                return hijo

        poblacion = nueva_poblacion
        print(f"Generación {generacion}: Mejor combinación: {mejor_individuo}, Aptitud: {mejor_aptitud}")

    print("No se encontró un objetivo después de todas las generaciones.")
    return mejor_individuo

tamanio_poblacion = 10
tasa_mutacion = 0.01
generaciones = 200

resultado = algoritmo_genetico(tamanio_poblacion, tasa_mutacion, generaciones)